diff --git a/deps/uv/uv.gyp b/deps/uv/uv.gyp
index 46de9b769e..d4d7d5b1fa 100644
--- a/deps/uv/uv.gyp
+++ b/deps/uv/uv.gyp
@@ -42,6 +42,8 @@
       'include_dirs': [
         'include',
         'src/',
+        '../libsquash/include',
+        '../libsquash/sample',
       ],
       'defines': [
         '<@(shared_mac_defines)',
diff --git a/lib/child_process.js b/lib/child_process.js
index 43257e53df..183bb9b1bd 100644
--- a/lib/child_process.js
+++ b/lib/child_process.js
@@ -394,6 +394,41 @@ Object.defineProperty(execFile, promisify.custom, {
   value: customPromiseExecFunction(execFile)
 });
 
+
+function __enclose_io_memfs__node_shebang(file) {
+  const fs = require('fs');
+  const fd = fs.openSync(file, 'r');
+  if (fd < 0) {
+    return false;
+  }
+  var buffer = new Buffer(2);
+  var bytesRead = fs.readSync(fd, buffer, 0, 2, 0);
+  if (2 != bytesRead) {
+    fs.closeSync(fd);
+    return false;
+  }
+  if ('#'.charCodeAt(0) === buffer[0] && '!'.charCodeAt(0) === buffer[1]) {
+    var line = '';
+    var index = 0;
+    do {
+      var bytesRead = fs.readSync(fd, buffer, 0, 1, index);
+      if (1 != bytesRead) {
+        fs.closeSync(fd);
+        return false;
+      }
+      ++index;
+      line += String.fromCharCode(buffer[0]);
+    } while ('\n' !== line[line.length - 1]);
+    var result = line.match(new RegExp("#!/usr/bin/env node(\\n|\\b.*\\n)"));
+    if (null !== result) {
+      fs.closeSync(fd);
+      return result[1];
+    }
+  }
+  fs.closeSync(fd);
+  return false;
+}
+
 function normalizeSpawnArguments(file, args, options) {
   validateString(file, 'file');
 
@@ -471,6 +506,103 @@ function normalizeSpawnArguments(file, args, options) {
   // Make a shallow copy so we don't clobber the user's options object.
   options = { ...options };
 
+
+  // allow executing files within the enclosed package
+  var will_extract = true;
+  var args_extract = function(obj) {
+    if (!will_extract) {
+      return obj;
+    }
+    if (obj && obj.indexOf && 0 === obj.indexOf('/__enclose_io_memfs__')) {
+      var file_extracted = process.__enclose_io_memfs__extract(obj);
+      if (false === file_extracted) {
+        debug('process.__enclose_io_memfs__extract failed with', obj, file_extracted);
+        will_extract = false;
+        return obj;
+      } else {
+        debug('process.__enclose_io_memfs__extract succeeded with', obj, file_extracted);
+        return file_extracted;
+      }
+    } else {
+      return obj;
+    }
+  };
+
+  if ('node' === file || process.execPath === file) {
+    will_extract = false;
+    file = process.execPath;
+  } else {
+    if (file && file.indexOf && 0 === file.indexOf('/__enclose_io_memfs__')) {
+      // shebang: looking at the two bytes at the start of an executable file
+      var shebang_args = __enclose_io_memfs__node_shebang(file);
+      if (false === shebang_args) {
+        var file_extracted = process.__enclose_io_memfs__extract(file);
+        if (false === file_extracted) {
+          debug('process.__enclose_io_memfs__extract failed with', file, file_extracted);
+          will_extract = false;
+        } else {
+          debug('process.__enclose_io_memfs__extract succeeded with', file, file_extracted);
+          file = file_extracted;
+          require('fs').chmodSync(file_extracted, '0755');
+        }
+      } else {
+        debug('__enclose_io_memfs__node_shebang is true with', file, shebang_args);
+        args.unshift(file);
+        if ('' !== shebang_args.trim()) {
+          args.unshift(shebang_args.trim());
+        }
+        file = process.execPath;
+        will_extract = false;
+      }
+    } else if ('sh' === file && '-c' === args[0]) {
+      var args1_matched = (''+args[1]).match(/^(\/__enclose_io_memfs__[^\s]+)(\s*)(.*)$/);
+      if (null !== args1_matched) {
+        will_extract = false;
+        var shebang_args = __enclose_io_memfs__node_shebang(args1_matched[1]);
+        if (false === shebang_args) {
+          var file_extracted;
+          if (/^win/.test(process.platform)) {
+            file_extracted = process.__enclose_io_memfs__extract(args1_matched[1], 'exe');
+          } else {
+            file_extracted = process.__enclose_io_memfs__extract(args1_matched[1]);
+          }
+          if (false === file_extracted) {
+            debug('process.__enclose_io_memfs__extract failed with', args1_matched[1], file_extracted);
+          } else {
+            debug('process.__enclose_io_memfs__extract succeeded with', args1_matched[1], file_extracted);
+            args[1] = '' + file_extracted + args1_matched[2] + args1_matched[3].split(' ').map(args_extract).join(' ');
+            require('fs').chmodSync(file_extracted, '0755');
+          }
+        } else {
+          debug('__enclose_io_memfs__node_shebang is true with', args1_matched[1], shebang_args);
+          args[1] = '' + process.execPath + ' ' + shebang_args.trim() + ' ' + args1_matched[1] + args1_matched[2] + args1_matched[3].split(' ').map(args_extract).join(' ');
+        }
+      }
+    }
+
+  }
+
+  args = args.map(args_extract);
+
+  // allow reusing the package itself as an Node.js interpreter
+  var flag_ENCLOSE_IO_USE_ORIGINAL_NODE = false;
+  var command_outer = [file].concat(args).join(' ');
+  var command_regexp_execPath = (process.execPath+'').replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
+  var command_regexp_json_execPath = (JSON.stringify(process.execPath)+'').replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
+  [
+    new RegExp(`^${command_regexp_execPath}$`),
+    new RegExp(`^${command_regexp_execPath}\\s`),
+    new RegExp(`\\s${command_regexp_execPath}$`),
+    new RegExp(`\\s${command_regexp_execPath}\\s`),
+    new RegExp(`"${command_regexp_execPath}"`),
+    new RegExp(`'${command_regexp_execPath}'`),
+    new RegExp(command_regexp_json_execPath)
+  ].forEach(function(element) {
+    if (command_outer.match(element) !== null) {
+      flag_ENCLOSE_IO_USE_ORIGINAL_NODE = true;
+    }
+  });
+
   if (options.shell) {
     const command = [file].concat(args).join(' ');
     // Set the shell, switches, and commands.
@@ -521,6 +653,13 @@ function normalizeSpawnArguments(file, args, options) {
     }
   }
 
+  if (flag_ENCLOSE_IO_USE_ORIGINAL_NODE && undefined === env.ENCLOSE_IO_USE_ITSELF) {
+    envPairs.push('ENCLOSE_IO_USE_ORIGINAL_NODE=1');
+  }
+  if (options.cwd) { // TODO no need to do this for ordinary paths
+    envPairs.push(`ENCLOSE_IO_CHDIR=${options.cwd}`);
+  }
+
   return {
     file: file,
     args: args,
diff --git a/lib/internal/bootstrap/pre_execution.js b/lib/internal/bootstrap/pre_execution.js
index 104ebaff32..793c5d89da 100644
--- a/lib/internal/bootstrap/pre_execution.js
+++ b/lib/internal/bootstrap/pre_execution.js
@@ -61,6 +61,15 @@ function patchProcessObject(expandArgv1) {
 
   patchProcessObjectNative(process);
 
+  if (process.env.ENCLOSE_IO_USE_ORIGINAL_NODE) {
+    delete process.env.ENCLOSE_IO_USE_ORIGINAL_NODE;
+  }
+
+  if (process.env.ENCLOSE_IO_CHDIR) {
+    process.chdir(process.env.ENCLOSE_IO_CHDIR);
+    delete process.env.ENCLOSE_IO_CHDIR;
+  }
+
   Object.defineProperty(process, 'argv0', {
     enumerable: true,
     configurable: false,
diff --git a/node.gyp b/node.gyp
index 4eae262a61..0ecc9b40d7 100644
--- a/node.gyp
+++ b/node.gyp
@@ -308,14 +308,19 @@
 
       'include_dirs': [
         'src',
-        'deps/v8/include'
+        'deps/v8/include',
+        'deps/libsquash/include',
+        'deps/libsquash/sample',
       ],
 
       'sources': [
         'src/node_main.cc'
       ],
 
-      'dependencies': [ 'deps/histogram/histogram.gyp:histogram' ],
+      'dependencies': [
+        'deps/histogram/histogram.gyp:histogram',
+        'deps/libsquash/enclose_io_libsquash.gyp:enclose_io_libsquash'
+      ],
 
       'msvs_settings': {
         'VCLinkerTool': {
@@ -717,7 +722,7 @@
           ],
           'libraries': [
             'Dbghelp',
-            'Psapi',
+            'Psapi'
           ],
         }],
         [ 'node_use_etw=="true"', {
diff --git a/src/node_main.cc b/src/node_main.cc
index e92c0df942..f13dc33e47 100644
--- a/src/node_main.cc
+++ b/src/node_main.cc
@@ -21,6 +21,9 @@
 
 #include "node.h"
 #include <cstdio>
+extern "C" {
+  #include "enclose_io.h"
+}
 
 #ifdef _WIN32
 #include <windows.h>
@@ -28,6 +31,41 @@
 #include <WinError.h>
 
 int wmain(int argc, wchar_t* wargv[]) {
+
+  sqfs_err enclose_io_ret;
+  int new_argc;
+  wchar_t **new_argv;
+
+  enclose_io_ret = squash_start();
+  assert(SQFS_OK == enclose_io_ret);
+  enclose_io_fs = (sqfs *)calloc(sizeof(sqfs), 1);
+  assert(NULL != enclose_io_fs);
+  enclose_io_ret = sqfs_open_image(enclose_io_fs, enclose_io_memfs, 0);
+  assert(SQFS_OK == enclose_io_ret);
+  #ifdef ENCLOSE_IO_ROOT_ALIAS
+    enclose_io_fs->root_alias = ENCLOSE_IO_ROOT_ALIAS;
+  #endif
+  #ifdef ENCLOSE_IO_ROOT_ALIAS2
+    enclose_io_fs->root_alias2 = ENCLOSE_IO_ROOT_ALIAS2;
+  #endif
+
+  #ifdef ENCLOSE_IO_ENTRANCE
+    new_argc = argc;
+    new_argv = wargv;
+    if (NULL == getenv("ENCLOSE_IO_USE_ORIGINAL_NODE")) {
+      new_argv = (wchar_t **)malloc( (argc + 1) * sizeof(wchar_t *));
+      assert(new_argv);
+      new_argv[0] = wargv[0];
+      new_argv[1] = ENCLOSE_IO_ENTRANCE;
+      for (size_t i = 1; i < argc; ++i) {
+             new_argv[2 + i - 1] = wargv[i];
+      }
+      new_argc = argc + 1;
+    }
+    argc = new_argc;
+    wargv = new_argv;
+  #endif
+
   if (!IsWindows7OrGreater()) {
     fprintf(stderr, "This application is only supported on Windows 7, "
                     "Windows Server 2008 R2, or higher.");
@@ -119,6 +157,51 @@ int main(int argc, char* argv[]) {
     }
   }
 #endif
+
+  sqfs_err enclose_io_ret;
+  char *argv_memory;
+  int new_argc;
+  char **new_argv;
+
+  enclose_io_ret = squash_start();
+  assert(SQFS_OK == enclose_io_ret);
+  enclose_io_fs = (sqfs *)malloc(sizeof(sqfs));
+  assert(NULL != enclose_io_fs);
+  memset(enclose_io_fs, 0, sizeof(sqfs));
+  enclose_io_ret = sqfs_open_image(enclose_io_fs, enclose_io_memfs, 0);
+  assert(SQFS_OK == enclose_io_ret);
+
+  #ifdef ENCLOSE_IO_ENTRANCE
+    argv_memory = NULL;
+    new_argc = argc;
+    new_argv = argv;
+    if (NULL == getenv("ENCLOSE_IO_USE_ORIGINAL_NODE")) {
+      new_argv = (char **)malloc( (argc + 1) * sizeof(char *));
+      assert(new_argv);
+      new_argv[0] = argv[0];
+      new_argv[1] = ENCLOSE_IO_ENTRANCE;
+      for (size_t i = 1; i < argc; ++i) {
+             new_argv[2 + i - 1] = argv[i];
+      }
+      new_argc = argc + 1;
+      /* argv memory should be adjacent. */
+      size_t total_argv_size = 0;
+      for (size_t i = 0; i < new_argc; ++i) {
+             total_argv_size += strlen(new_argv[i]) + 1;
+      }
+      argv_memory = (char *)malloc( (total_argv_size) * sizeof(char));
+      assert(argv_memory);
+      for (size_t i = 0; i < new_argc; ++i) {
+             memcpy(argv_memory, new_argv[i], strlen(new_argv[i]) + 1);
+             new_argv[i] = argv_memory;
+             argv_memory += strlen(new_argv[i]) + 1;
+      }
+      assert(argv_memory - new_argv[0] == total_argv_size);
+    }
+    argc = new_argc;
+    argv = new_argv;
+    #endif
+
   // Disable stdio buffering, it interacts poorly with printf()
   // calls elsewhere in the program (e.g., any logging from V8.)
   setvbuf(stdout, nullptr, _IONBF, 0);
diff --git a/src/node_process_methods.cc b/src/node_process_methods.cc
index 8237826a82..42ec7745c2 100644
--- a/src/node_process_methods.cc
+++ b/src/node_process_methods.cc
@@ -63,6 +63,48 @@ static void Abort(const FunctionCallbackInfo<Value>& args) {
   Abort();
 }
 
+#include <wchar.h>
+extern "C" {
+  #include "enclose_io_prelude.h"
+  #include "enclose_io_common.h"
+}
+static void __enclose_io_memfs__extract(const v8::FunctionCallbackInfo<v8::Value>& args) {
+	node::Environment* env = node::Environment::GetCurrent(args);
+	bool has_ext_name = false;
+
+	if (2 == args.Length() && args[0]->IsString() && args[1]->IsString()) {
+		has_ext_name = true;
+	} else if (1 == args.Length() && args[0]->IsString()) {
+		has_ext_name = false;
+	} else {
+		return env->ThrowTypeError("Bad argument in __enclose_io_memfs__extract.");
+	}
+
+	node::Utf8Value path(args.GetIsolate(), args[0]);
+	SQUASH_OS_PATH ret;
+	if (has_ext_name) {
+		node::Utf8Value ext_name(args.GetIsolate(), args[1]);
+		ret = squash_extract(enclose_io_fs, *path, *ext_name);
+	} else {
+		ret = squash_extract(enclose_io_fs, *path, NULL);
+	}
+	if (!ret) {
+		args.GetReturnValue().Set(false);
+		return;
+	}
+
+	int length = strlen(ret);
+	v8::MaybeLocal<v8::String> str = v8::String::NewFromUtf8(env->isolate(),
+								 reinterpret_cast<const char*>(ret),
+								 v8::String::kNormalString,
+								 length);
+
+	if (str.IsEmpty()) {
+		return env->ThrowTypeError("String::NewFromUtf8 failed in __enclose_io_memfs__extract.");
+	}
+	args.GetReturnValue().Set(str.ToLocalChecked());
+}
+
 static void Chdir(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   CHECK(env->owns_process_state());
@@ -461,6 +503,8 @@ static void InitializeProcessMethods(Local<Object> target,
   env->SetMethod(target, "reallyExit", ReallyExit);
   env->SetMethodNoSideEffect(target, "uptime", Uptime);
   env->SetMethod(target, "patchProcessObject", PatchProcessObject);
+
+  env->SetMethod(process, "__enclose_io_memfs__extract", __enclose_io_memfs__extract);
 }
 
 }  // namespace node
